#!/usr/bin/env python3
"""
Local LLM command‑agent with safe blank‑line paste support
and Vi‑style key‑bindings on every `input()`.
"""

import sys
import subprocess
import asyncio
import dspy
import mlflow
from rich import print as rp

# ── enable Vi key‑bindings in all readline prompts ────────────────────────────
try:
    import readline
    readline.parse_and_bind("set editing-mode vi")
except Exception:
    pass  # readline might be missing on some platforms

# ── MLflow / dspy setup ───────────────────────────────────────────────────────
mlflow.set_tracking_uri("http://localhost:5002")
mlflow.set_experiment("local_agent")
mlflow.dspy.autolog()

# lm = dspy.LM('ollama_chat/deepseek-r1:7b', api_base='http://localhost:11434', api_key='')
lm = dspy.LM("openrouter/deepseek/deepseek-r1-0528", max_tokens=40000)
# lm = dspy.LM('openrouter/google/gemini-2.5-flash-lite-preview-06-17')
dspy.configure(lm=lm)

python_code_generator = dspy.Predict(
    "user_request, system_state_info, python_code_to_run_history, return_value -> python_code_to_run"
)
command_generator = dspy.Predict(
    "user_request, system_state_info, command_run_history, return_value -> command"
)
safety_checker = dspy.Predict(
    "command_run_history, command, user_request -> command_is_safe_to_execute: bool, reasoning",
    instructions=(
        "The commands are generated by an LLM and we trust the LLM to not be malicious. "
        "The LLM is working unsupervised. Commands that reveal sensitive data such as API keys, "
        "production encryption keys, diary entries, personal taskmanager tasks, personal time tracking, "
        "then it is not safe to run. If the command is not obviously dangerous, reveals sensitive data "
        "and is not very hard to impossible to undo (like an rm command of files existing before the "
        "session started) then it should be marked as safe"
    ),
)
is_finished_checker = dspy.Predict(
    "user_request, system_state_info, command_run_history, return_value -> reasoning, is_finished: bool",
    instructions=(
        "The agent is finished if the user request has been fulfilled. "
        "The user request is fulfilled if the return value contains the answer to the user request "
        "or if the user request is a command that has been executed successfully."
    ),
)

# ── helper: blank‑line‑terminated multiline input ─────────────────────────────
def multiline_input(prompt: str = "Paste below (empty line = done):") -> str:
    print(prompt)
    buf = []
    while True:
        try:
            line = input()
        except EOFError:  # still works if user sends Ctrl‑D
            break
        if line == "":
            break
        buf.append(line)
    return "\n".join(buf)


# ── initial user request ───────────────────────────────────────────────────────
if len(sys.argv) > 1:
    user_request = " ".join(sys.argv[1:])
else:
    user_request = multiline_input()

system_state_info = ""
return_value = ""
python_code_run_history = []
command_run_history = []

# ── main loop ─────────────────────────────────────────────────────────────────
while True:
    command = command_generator(
        user_request=user_request,
        system_state_info=system_state_info,
        command_run_history=command_run_history,
        return_value=return_value,
    ).command

    rp(f"[cyan]command[/]: {command}")

    result = safety_checker(
        command=command, command_run_history=command_run_history, user_request=user_request
    )
    command_is_safe_to_execute, reasoning = result.command_is_safe_to_execute, result.reasoning
    color = "green" if command_is_safe_to_execute else "red"
    rp(f"[cyan]command_is_safe_to_execute:[/] [{color}] {command_is_safe_to_execute} [/]")
    print("reasoning:", reasoning)

    if command_is_safe_to_execute:
        try:
            result = subprocess.run(command, shell=True, capture_output=True, text=True)
            return_value = str(result)
            print("return_value:", return_value)
        except Exception as e:
            return_value = str(e)
    else:
        return_value = (
            "Command wasn't executed because it was determined to be unsafe. "
            f"Reasoning: {reasoning}"
        )

    command_run_history.append({"command": command, "return_value": return_value})

    is_finished_result = is_finished_checker(
        user_request=user_request,
        system_state_info=system_state_info,
        command_run_history=command_run_history,
        return_value=return_value,
    )
    rp(f"[cyan]is_finished:[/] {is_finished_result.is_finished}")
    print("is_finished_result.reasoning:", is_finished_result.reasoning)

    if is_finished_result.is_finished:
        rp("[green]Finished![/]")
        user_request = multiline_input()
